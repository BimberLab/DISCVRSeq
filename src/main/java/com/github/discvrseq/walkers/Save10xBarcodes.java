package com.github.discvrseq.walkers;

import com.github.discvrseq.tools.DiscvrSeqProgramGroup;
import com.github.discvrseq.util.CsvUtils;
import com.opencsv.ICSVWriter;
import htsjdk.samtools.util.IOUtil;
import org.apache.commons.lang3.tuple.Pair;
import org.broadinstitute.barclay.argparser.Argument;
import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;
import org.broadinstitute.barclay.help.DocumentedFeature;
import org.broadinstitute.hellbender.engine.FeatureContext;
import org.broadinstitute.hellbender.engine.ReadWalker;
import org.broadinstitute.hellbender.engine.ReferenceContext;
import org.broadinstitute.hellbender.engine.filters.ReadFilter;
import org.broadinstitute.hellbender.utils.read.GATKRead;

import java.io.File;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This walker will iterate a BAM generated FASTQ or pair of FASTQs and print any reads matching the supplied expressions.  Expressions can be simple strings or a java regular expression.
 *
 *
 * <h3>Usage examples:</h3>
 * <h4>Simple search for a sequence in either forward or reverse read:</h4>
 * <pre>
 *  java -jar DISCVRseq.jar Save10xBarcodes \
 *     --input theBam.bam \
 *     --output bcOutput.txt.gz
 * </pre>
 *
 */
@DocumentedFeature
@CommandLineProgramProperties(
        summary = "This tool iterates a BAM file generated by 10x Genomics CellRanger software, and saves all unique Raw and Corrected cell barcodes and UMIs.",
        oneLineSummary = "Print all CR/CB and UR/UB combinations",
        programGroup = DiscvrSeqProgramGroup.class
)
public class Save10xBarcodes extends ReadWalker {
    @Argument(fullName = "output", doc = "The output file for cell barcode / UMIs", optional = false)
    private File outputFile = null;

    @Override
    public void onTraversalStart() {
        super.onTraversalStart();

        IOUtil.assertFileIsWritable(outputFile);
    }

    Map<String, String> rawToCorrected = new HashMap<>();

    private long totalReadsMissingCB = 0;
    private long totalReadsMissingUB = 0;

    @Override
    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {
        Pair<String, String> cbMap = null;
        Pair<String, String> umiMap = null;
        if (!read.hasAttribute("CB")) {
            totalReadsMissingCB++;
            if (totalReadsMissingCB == 1) {
                logger.info("Missing 'CB' attribute in read {}. This will only be logged once.", read.getName());
            }
            return;
        }

        if (!read.hasAttribute("UB")) {
            // NOTE: UMI correction is only performed on reads with a valid cell barcode.
            if (read.hasAttribute("CB")) {
                totalReadsMissingUB++;
                if (totalReadsMissingUB == 1) {
                    logger.info("Missing 'UB' attribute in read {}. This will only be logged once.", read.getName());
                }
            }

            return;
        }

        if (read.hasAttribute("CR")) {
            cbMap = Pair.of(read.getAttributeAsString("CR"), read.getAttributeAsString("CB"));
        }
        else {
            cbMap = Pair.of(read.getAttributeAsString("CB"), read.getAttributeAsString("CB"));
        }

        if (read.hasAttribute("UR")) {
            umiMap = Pair.of(read.getAttributeAsString("UR"), read.getAttributeAsString("UB"));
        }
        else {
            umiMap = Pair.of(read.getAttributeAsString("UB"), read.getAttributeAsString("UB"));
        }

        String key = cbMap.getKey() + "<>" + umiMap.getKey();
        String value = cbMap.getValue() + DELIM + umiMap.getValue();

        if (rawToCorrected.containsKey(key) && !rawToCorrected.get(key).equals(value)) {
            throw new IllegalStateException("Key already present: " + key + ", but existing value (" + rawToCorrected.get(key) + ") differs from current row: " + value);
        }

        rawToCorrected.put(key, value);
    }

    private static final String DELIM = "<>";

    @Override
    public Object onTraversalSuccess() {
        logger.info("Total Raw CB/UMI combinations: {}", rawToCorrected.size());
        logger.info("Total Reads Missing CB: {}", totalReadsMissingCB);
        logger.info("Total Reads Missing UB: {}", totalReadsMissingUB);

        try (ICSVWriter writer = CsvUtils.getTsvWriter(outputFile)) {
            writer.writeNext(new String[]{"RawCellBarcode", "CorrectedCellBarcode", "RawUMI", "CorrectedUMI"});
            rawToCorrected.forEach((key, value) -> {
                String[] rawVals = key.split(DELIM);
                String[] correctedVals = value.split(DELIM);

                writer.writeNext(new String[]{rawVals[0], correctedVals[0], rawVals[1], correctedVals[1]});
            });
        }
        catch (IOException e)
        {
            logger.error(e.getMessage(), e);
        }

        return null;
    }

    @Override
    public List<ReadFilter> getDefaultReadFilters() {
        return Collections.emptyList();
    }
}
