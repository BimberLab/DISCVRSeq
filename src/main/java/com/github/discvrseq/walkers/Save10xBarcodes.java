package com.github.discvrseq.walkers;

import com.github.discvrseq.tools.DiscvrSeqProgramGroup;
import com.github.discvrseq.util.CsvUtils;
import com.opencsv.ICSVWriter;
import htsjdk.samtools.util.IOUtil;
import org.broadinstitute.barclay.argparser.Argument;
import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;
import org.broadinstitute.barclay.help.DocumentedFeature;
import org.broadinstitute.hellbender.engine.FeatureContext;
import org.broadinstitute.hellbender.engine.ReadWalker;
import org.broadinstitute.hellbender.engine.ReferenceContext;
import org.broadinstitute.hellbender.utils.read.GATKRead;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * This walker will iterate FASTQ or pair of FASTQs and print any reads matching the supplied expressions.  Expressions can be simple strings or a java regular expression.
 *
 *
 * <h3>Usage examples:</h3>
 * <h4>Simple search for a sequence in either forward or reverse read:</h4>
 * <pre>
 *  java -jar DISCVRseq.jar Save10xBarcodes \
 *     --bam theBam.bam \
 *     --cbOutput cbOutput.txt.gz \
 *     -umiOutput umiOutput.txt.gz
 * </pre>
 *
 */
@DocumentedFeature
@CommandLineProgramProperties(
        summary = "This tool iterates a BAM file generated by 10x Genomics CellRanger software, and saves all unique Raw and Corrected cell barcodes and UMIs.",
        oneLineSummary = "Print all CR/CB and UR/UB combinations",
        programGroup = DiscvrSeqProgramGroup.class
)
public class Save10xBarcodes extends ReadWalker {
    @Argument(fullName="bam", doc="Input BAM file, produced by CellRanger")
    public File bam;

    @Argument(fullName = "cbOutput", doc = "The output file for cell barcodes", optional = false)
    private File outputFile1 = null;

    @Argument(fullName = "umiOutput", doc = "The output file for UMIs", optional = false)
    private File outputFile2 = null;

    @Override
    public void onTraversalStart() {
        super.onTraversalStart();

        IOUtil.assertFileIsReadable(bam);
        IOUtil.assertFileIsWritable(outputFile1);
        IOUtil.assertFileIsWritable(outputFile2);


    }

    Map<String, String> rawToCorrectedCB = new HashMap<>();
    Map<String, String> rawToCorrectedUMI = new HashMap<>();

    @Override
    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {
        if (!read.hasAttribute("CB")) {
            logger.info("Missing 'CB' attribute in read %s", read.getName());
        }
        else if (read.hasAttribute("CR")) {
            rawToCorrectedCB.put(read.getAttributeAsString("CR"), read.getAttributeAsString("CB"));
        }
        else {
            rawToCorrectedCB.put(read.getAttributeAsString("CB"), read.getAttributeAsString("CB"));
        }

        if (!read.hasAttribute("UB")) {
            logger.info("Missing 'UB' attribute in read %s", read.getName());
            return;
        }
        else if (read.hasAttribute("UR")) {
            rawToCorrectedUMI.put(read.getAttributeAsString("UR"), read.getAttributeAsString("UB"));
        }
        else {
            rawToCorrectedUMI.put(read.getAttributeAsString("UB"), read.getAttributeAsString("UB"));
        }
    }

    @Override
    public Object onTraversalSuccess() {
        logger.info("Total Cell Barcodes: %s", rawToCorrectedCB.size());
        try (ICSVWriter writer = CsvUtils.getTsvWriter(outputFile1)) {
            writer.writeNext(new String[]{"RawCellBarcode", "CorrectedCellBarcode"});
            rawToCorrectedCB.forEach((key, value) -> writer.writeNext(new String[]{key, value}));
        }
        catch (IOException e)
        {
            logger.error(e.getMessage(), e);
        }

        logger.info("Total UMIs: %s", rawToCorrectedUMI.size());
        try (ICSVWriter writer = CsvUtils.getTsvWriter(outputFile2)) {
            writer.writeNext(new String[]{"RawUMI", "CorrectedUMI"});
            rawToCorrectedUMI.forEach((key, value) -> writer.writeNext(new String[]{key, value}));
        }
        catch (IOException e)
        {
            logger.error(e.getMessage(), e);
        }

        return null;
    }
}
