package com.github.discvrseq.walkers;

import com.github.discvrseq.tools.DiscvrSeqProgramGroup;
import com.github.discvrseq.util.CsvUtils;
import com.opencsv.ICSVWriter;
import htsjdk.samtools.util.IOUtil;
import org.apache.commons.lang3.tuple.Pair;
import org.broadinstitute.barclay.argparser.Argument;
import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;
import org.broadinstitute.barclay.help.DocumentedFeature;
import org.broadinstitute.hellbender.engine.FeatureContext;
import org.broadinstitute.hellbender.engine.ReadWalker;
import org.broadinstitute.hellbender.engine.ReferenceContext;
import org.broadinstitute.hellbender.engine.filters.ReadFilter;
import org.broadinstitute.hellbender.utils.read.GATKRead;

import java.io.File;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This walker will iterate a CellRanger-generated BAM and save a TSV with all combinations of corrected and raw cell barcodes.
 *
 * <h3>Usage example:</h3>
 * <pre>
 *  java -jar DISCVRseq.jar Save10xBarcodes \
 *     --input theBam.bam \
 *     --output bcOutput.txt.gz
 * </pre>
 *
 */
@DocumentedFeature
@CommandLineProgramProperties(
        summary = "This tool iterates a BAM file generated by 10x Genomics CellRanger software, and saves all unique raw and corrected cell barcodes.",
        oneLineSummary = "Save all CR/CB combinations",
        programGroup = DiscvrSeqProgramGroup.class
)
public class Save10xBarcodes extends ReadWalker {
    @Argument(fullName = "output", doc = "The output file for cell barcode corrected/uncorrect combinations", optional = false)
    private File outputFile = null;

    @Override
    public void onTraversalStart() {
        super.onTraversalStart();

        IOUtil.assertFileIsWritable(outputFile);
    }

    Map<String, String> rawToCorrected = new HashMap<>();

    private long totalReadsMissingCB = 0;

    @Override
    public void apply(GATKRead read, ReferenceContext referenceContext, FeatureContext featureContext) {
        if (!read.hasAttribute("CB")) {
            totalReadsMissingCB++;
            if (totalReadsMissingCB == 1) {
                logger.info("Missing 'CB' attribute in read {}. This will only be logged once.", read.getName());
            }
            return;
        }

        String raw = read.hasAttribute("CR") ? read.getAttributeAsString("CR") :read.getAttributeAsString("CB");
        String corrected = read.getAttributeAsString("CB");

        if (rawToCorrected.containsKey(raw) && !rawToCorrected.get(raw).equals(corrected)) {
            throw new IllegalStateException("Key already present: " + raw + ", but existing value (" + rawToCorrected.get(raw) + ") differs from current row: " + corrected);
        }

        rawToCorrected.put(raw, corrected);
    }

    private static final String DELIM = "<>";

    @Override
    public Object onTraversalSuccess() {
        logger.info("Total Raw CB/UMI combinations: {}", rawToCorrected.size());
        logger.info("Total Reads Missing CB: {}", totalReadsMissingCB);

        try (ICSVWriter writer = CsvUtils.getTsvWriter(outputFile)) {
            writer.writeNext(new String[]{"RawCellBarcode", "CorrectedCellBarcode"});
            rawToCorrected.forEach((raw, corrected) -> {
                writer.writeNext(new String[]{raw, corrected});
            });
        }
        catch (IOException e)
        {
            logger.error(e.getMessage(), e);
        }

        return null;
    }

    @Override
    public List<ReadFilter> getDefaultReadFilters() {
        return Collections.emptyList();
    }
}
